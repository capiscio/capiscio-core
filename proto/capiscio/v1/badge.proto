// Badge service for Trust Badge signing and verification (RFC-002)
syntax = "proto3";

package capiscio.v1;

option go_package = "github.com/capiscio/capiscio-core/pkg/rpc/gen/capiscio/v1";

// BadgeService handles Trust Badge operations
service BadgeService {
  // Sign a new badge with the provided claims
  rpc SignBadge(SignBadgeRequest) returns (SignBadgeResponse);
  
  // Verify a badge token (basic verification)
  rpc VerifyBadge(VerifyBadgeRequest) returns (VerifyBadgeResponse);
  
  // Verify a badge with full options (online checks, etc.)
  rpc VerifyBadgeWithOptions(VerifyBadgeWithOptionsRequest) returns (VerifyBadgeResponse);
  
  // Parse badge claims without verification
  rpc ParseBadge(ParseBadgeRequest) returns (ParseBadgeResponse);
  
  // Request a badge from a Certificate Authority (RFC-002 §12.1)
  // This is for production use where badges are issued by CapiscIO registry
  rpc RequestBadge(RequestBadgeRequest) returns (RequestBadgeResponse);
  
  // Request a badge using Proof of Possession (RFC-003)
  // This provides IAL-1 assurance with cryptographic key binding
  rpc RequestPoPBadge(RequestPoPBadgeRequest) returns (RequestPoPBadgeResponse);
  
  // Create a Domain Validated (DV) badge order (RFC-002 v1.2)
  rpc CreateDVOrder(CreateDVOrderRequest) returns (CreateDVOrderResponse);
  
  // Get DV order status
  rpc GetDVOrder(GetDVOrderRequest) returns (GetDVOrderResponse);
  
  // Finalize DV order and receive grant
  rpc FinalizeDVOrder(FinalizeDVOrderRequest) returns (FinalizeDVOrderResponse);
  
  // Start a badge keeper that automatically renews badges (RFC-002 §7.3)
  // Returns a stream of keeper events (started, renewed, error, stopped)
  rpc StartKeeper(StartKeeperRequest) returns (stream KeeperEvent);
}

// Trust level for badges (RFC-002 v1.1)
enum TrustLevel {
  TRUST_LEVEL_UNSPECIFIED = 0;
  TRUST_LEVEL_SELF_SIGNED = 1;  // Self-signed (Level 0, did:key)
  TRUST_LEVEL_DV = 2;           // Domain Validated (Level 1)
  TRUST_LEVEL_OV = 3;           // Organization Validated (Level 2)
  TRUST_LEVEL_EV = 4;           // Extended Validated (Level 3)
  TRUST_LEVEL_CV = 5;           // Community Vouched (Level 4)
}

// Badge claims structure
message BadgeClaims {
  string jti = 1;           // JWT ID - unique identifier
  string iss = 2;           // Issuer URL
  string sub = 3;           // Subject (did:web identifier)
  int64 iat = 4;            // Issued At (Unix timestamp)
  int64 exp = 5;            // Expiration (Unix timestamp)
  int64 nbf = 6;            // Not Before (Unix timestamp)
  repeated string aud = 7;  // Audience
  TrustLevel trust_level = 8;
  string domain = 9;
  string agent_name = 10;
  string scope = 11;
}

// Request to sign a badge
message SignBadgeRequest {
  BadgeClaims claims = 1;
  // Private key in JWK format (JSON string)
  string private_key_jwk = 2;
  // Key ID for the signing key
  string key_id = 3;
}

// Response with signed badge
message SignBadgeResponse {
  string token = 1;  // Signed JWT token
  BadgeClaims claims = 2;
}

// Request to verify a badge
message VerifyBadgeRequest {
  string token = 1;
  // Public key in JWK format (JSON string) - optional if JWKS URL used
  string public_key_jwk = 2;
}

// Verification mode
enum VerifyMode {
  VERIFY_MODE_UNSPECIFIED = 0;
  VERIFY_MODE_OFFLINE = 1;   // Local verification only
  VERIFY_MODE_ONLINE = 2;    // Full online checks
  VERIFY_MODE_HYBRID = 3;    // Online if cache stale
}

// Options for badge verification
message VerifyOptions {
  VerifyMode mode = 1;
  repeated string trusted_issuers = 2;
  string audience = 3;
  bool skip_revocation = 4;
  bool skip_agent_status = 5;
  int64 clock_tolerance_seconds = 6;
  string registry_url = 7;
  bool accept_self_signed = 8;  // Accept Level 0 did:key badges
  // RFC-002 v1.3 §7.5: Staleness fail-closed behavior
  bool fail_open = 9;                    // If true, allow verification when cache is stale (default: false)
  int64 stale_threshold_seconds = 10;    // Max staleness before fail-closed (default: 300 = 5 min)
}

// Request to verify with options
message VerifyBadgeWithOptionsRequest {
  string token = 1;
  VerifyOptions options = 2;
}

// Badge verification result
message VerifyBadgeResponse {
  bool valid = 1;
  BadgeClaims claims = 2;
  VerifyMode mode_used = 3;
  repeated string warnings = 4;
  string error_code = 5;
  string error_message = 6;
}

// Request to parse badge without verification
message ParseBadgeRequest {
  string token = 1;
}

// Response with parsed claims
message ParseBadgeResponse {
  BadgeClaims claims = 1;
  string error_message = 2;
}

// ============================================================================
// Badge Request from CA (RFC-002 §12.1)
// ============================================================================

// Request to obtain a badge from a Certificate Authority
message RequestBadgeRequest {
  // Agent ID (UUID) to request badge for
  string agent_id = 1;
  
  // CA URL (default: https://registry.capisc.io)
  string ca_url = 2;
  
  // API key for authentication with the CA
  string api_key = 3;
  
  // Agent domain (optional, uses agent's registered domain if not provided)
  string domain = 4;
  
  // Requested TTL in seconds (default: 300, per RFC-002)
  int32 ttl_seconds = 5;
  
  // Requested trust level (1-4, default: 1)
  TrustLevel trust_level = 6;
  
  // Optional audience restrictions
  repeated string audience = 7;
}

// Response from badge request
message RequestBadgeResponse {
  // Whether the request succeeded
  bool success = 1;
  
  // The signed badge token (JWS)
  string token = 2;
  
  // Badge ID (jti)
  string jti = 3;
  
  // Subject DID
  string subject = 4;
  
  // Trust level assigned
  TrustLevel trust_level = 5;
  
  // When the badge expires (Unix timestamp)
  int64 expires_at = 6;
  
  // Error message if success=false
  string error = 7;
  
  // Error code (RFC-002 §8.4 codes)
  string error_code = 8;
}

// ============================================================================
// Badge Request with Proof of Possession (RFC-003)
// ============================================================================

// Request to obtain a badge using the PoP protocol (RFC-003)
message RequestPoPBadgeRequest {
  // Agent DID (e.g., did:web:registry.capisc.io:agents:my-agent or did:key:z6Mk...)
  string agent_did = 1;
  
  // Private key in JWK format (JSON string) for signing the PoP proof
  string private_key_jwk = 2;
  
  // CA URL (default: https://registry.capisc.io)
  string ca_url = 3;
  
  // API key for authentication with the CA
  string api_key = 4;
  
  // Requested TTL in seconds (default: 300, per RFC-002)
  int32 ttl_seconds = 5;
  
  // Optional audience restrictions for the issued badge
  repeated string audience = 6;
}

// Response from PoP badge request
message RequestPoPBadgeResponse {
  // Whether the request succeeded
  bool success = 1;
  
  // The signed badge token (JWS)
  string token = 2;
  
  // Badge ID (jti)
  string jti = 3;
  
  // Subject DID
  string subject = 4;
  
  // Trust level assigned
  string trust_level = 5;
  
  // Assurance level (always "IAL-1" for PoP badges)
  string assurance_level = 6;
  
  // When the badge expires (Unix timestamp)
  int64 expires_at = 7;
  
  // CNF claim (key binding)
  map<string, string> cnf = 8;
  
  // Error message if success=false
  string error = 9;
  
  // Error code
  string error_code = 10;
}

// ============================================================================
// Badge Keeper (RFC-002 §7.3)
// ============================================================================

// Request to start a badge keeper daemon
message StartKeeperRequest {
  // Mode: CA or self-signed
  KeeperMode mode = 1;
  
  // Agent ID (required for CA mode)
  string agent_id = 2;
  
  // CA URL (default: https://registry.capisc.io)
  string ca_url = 3;
  
  // API key for CA authentication (required for CA mode)
  string api_key = 4;
  
  // Output file path for the badge
  string output_file = 5;
  
  // Badge TTL in seconds (default: 300)
  int32 ttl_seconds = 6;
  
  // Time before expiry to renew, in seconds (default: 60)
  int32 renew_before_seconds = 7;
  
  // Check interval in seconds (default: 30)
  int32 check_interval_seconds = 8;
  
  // Private key path (required for self-sign mode, JWK file)
  string private_key_path = 9;
  
  // Domain for the badge
  string domain = 10;
  
  // Trust level (for CA mode, 1-4; self-sign always 0)
  TrustLevel trust_level = 11;
}

// Keeper operation mode
enum KeeperMode {
  KEEPER_MODE_UNSPECIFIED = 0;
  KEEPER_MODE_CA = 1;         // Request badges from CA
  KEEPER_MODE_SELF_SIGN = 2;  // Self-sign badges locally (development)
}

// Event types emitted by the keeper
enum KeeperEventType {
  KEEPER_EVENT_UNSPECIFIED = 0;
  KEEPER_EVENT_STARTED = 1;   // Keeper started successfully
  KEEPER_EVENT_RENEWED = 2;   // Badge was renewed
  KEEPER_EVENT_ERROR = 3;     // An error occurred (non-fatal)
  KEEPER_EVENT_STOPPED = 4;   // Keeper stopped (client disconnect or fatal error)
}

// Event emitted by the badge keeper
message KeeperEvent {
  // Event type
  KeeperEventType type = 1;
  
  // Badge JTI (for RENEWED events)
  string badge_jti = 2;
  
  // Subject DID (for RENEWED events)
  string subject = 3;
  
  // Trust level (for RENEWED events)
  TrustLevel trust_level = 4;
  
  // When the badge expires (Unix timestamp, for RENEWED events)
  int64 expires_at = 5;
  
  // Error message (for ERROR events)
  string error = 6;
  
  // Error code (for ERROR events)
  string error_code = 7;
  
  // Timestamp of the event (Unix timestamp)
  int64 timestamp = 8;
  
  // The badge token itself (for RENEWED events, optional)
  string token = 9;
}

// ============================================================================
// Domain Validated (DV) Badge Orders (RFC-002 v1.2)
// ============================================================================

// Request to create a DV badge order
message CreateDVOrderRequest {
  // Domain to validate (e.g., "example.com")
  string domain = 1;
  
  // Challenge type: "http-01" or "dns-01"
  string challenge_type = 2;
  
  // Public key in JWK format (JSON string)
  string jwk = 3;
  
  // CA URL (default: https://registry.capisc.io)
  string ca_url = 4;
}

// Response from DV order creation
message CreateDVOrderResponse {
  // Whether the request succeeded
  bool success = 1;
  
  // Order ID (UUID)
  string order_id = 2;
  
  // Domain
  string domain = 3;
  
  // Challenge type
  string challenge_type = 4;
  
  // Challenge token
  string challenge_token = 5;
  
  // Order status ("pending", "valid", "invalid")
  string status = 6;
  
  // Validation URL (for HTTP-01)
  string validation_url = 7;
  
  // DNS record value (for DNS-01)
  string dns_record = 8;
  
  // When the order expires (Unix timestamp)
  int64 expires_at = 9;
  
  // Error message if success=false
  string error = 10;
  
  // Error code
  string error_code = 11;
}

// Request to get DV order status
message GetDVOrderRequest {
  // Order ID (UUID)
  string order_id = 1;
  
  // CA URL (default: https://registry.capisc.io)
  string ca_url = 2;
}

// Response with DV order status
message GetDVOrderResponse {
  // Whether the request succeeded
  bool success = 1;
  
  // Order ID (UUID)
  string order_id = 2;
  
  // Domain
  string domain = 3;
  
  // Challenge type
  string challenge_type = 4;
  
  // Challenge token
  string challenge_token = 5;
  
  // Order status
  string status = 6;
  
  // Validation URL (for HTTP-01)
  string validation_url = 7;
  
  // DNS record value (for DNS-01)
  string dns_record = 8;
  
  // When the order expires (Unix timestamp)
  int64 expires_at = 9;
  
  // When the order was finalized (Unix timestamp, optional)
  int64 finalized_at = 10;
  
  // Error message if success=false
  string error = 11;
  
  // Error code
  string error_code = 12;
}

// Request to finalize DV order
message FinalizeDVOrderRequest {
  // Order ID (UUID)
  string order_id = 1;
  
  // CA URL (default: https://registry.capisc.io)
  string ca_url = 2;
}

// Response from DV order finalization
message FinalizeDVOrderResponse {
  // Whether the request succeeded
  bool success = 1;
  
  // DV grant JWT
  string grant = 2;
  
  // When the grant expires (Unix timestamp)
  int64 expires_at = 3;
  
  // Error message if success=false
  string error = 4;
  
  // Error code
  string error_code = 5;
}
